
这本书到底讲什么？

本书按照内容可以分为三个部分：过程抽象（第一章）；数据抽象（第二、三章）和语言抽象（第四、五章）。

过程抽象部分比较简单，先介绍了Scheme的基本语法，让读者初步领略函数式编程的风采。

对于有一定编程基础（相信国内极少有人入门就读这个）的读者来说，会有耳目一新的感觉，原来递归和迭代可以有另一种表现形式，但并不难理解。

习题也比较简单，不会用掉太多的时间。过程抽象的概念也很简单，就是编程语言中的函数，目的是封装计算过程的细节。

关于何时应该用过程抽象的原则是：一切可以定义为过程的计算片段都应该定义为过程。

数据抽象是我认为的本书的核心，也是最值得我们仔细研读的部分。关于数据抽象最直接的理解就是面向对象编程，如C++，而Java和C#则是更彻底的数据抽象。

把一组过程抽象（类的方法）集中考虑，并加入内部状态（类的变量），就是一个数据抽象。每个数据抽象都应该把自己的内部对象状态和对象的实现隐藏起来，

对外通过一组接口进行消息传递。这样听起来好像本书与一般的面向对象书没有区别，但实际上，这些都是我自己的总结，书里面不会把这些概念直接罗列出来，

而是通过一个个巧妙的例子，让读者一步步深入，感叹原来A还可以这样抽象，原来B还可以这样封装。个人认为如果时间有限，读完前三章已经可以领会本书大

部分思想了，后两章可以不读。

语言抽象是指自己发明一门语言，以解决某一特定应用领域的问题。在这一领域中，自己发明的语言会比其他通用语言更方便。

定义了新语言的语法后，就要自己去实现该语言的编译器或解释器，可以通过现有的语言去构造。这一部分包含了许多编译方面的知识，

但又与编译原理中的构造方法有不少区别，自己看书很容易看得云里雾里，听老师讲课才好一些。大部分习题很难做，一部分习题非常难。

第一章讨论程序设计的最基本原则：原语（primitive expressions）、组合（means of composition）和抽象（means of abstraction），

以及如何利用这些基本原则化解复杂度。重点是过程抽象和高阶过程（high-order procedures）。本章的例题十分精彩，抽象和组合的过程十分清晰。

有关递归和迭代的讨论也非常耐读。

第二章讨论数据抽象，即利用基本数据构造复杂结构。Scheme里的基本构造能力只有cons，但由此可以组合出所有实用的结构。

图像语言、符号运算、集合表示、哈夫曼编码和复数系统都是经典实用的例子。顺带还介绍了data-directed方法，与面向对象中的封装有异曲同工之妙。

即使没有太多时间，我觉得前两章也值得值得细读。尤其是例子。

第三章主要讨论了状态（local state）和环境（environment model），可变数据结构（mutable data），以及状态和时间的交互（concurrency和laziness）。

前两章用到语言是Scheme的一个没有副作用的子集，从这一章开始涉及解释器的核心机制，尤其是状态的管理，及其优缺点。

第四章用Scheme实现了一个简单的Scheme解释器。重点是讨论语言的解释过程，以及如何针对问题（领域）创造和修改语言，

从中可见DSL（Domain Specific Language）的思想。后三节各自讨论一个工程中不常见但高效解决特定问题的语言变种及其实现。

第五章介绍将Scheme编译为现实中的寄存器机器模型（register machine）。重点不是编译技巧（Scheme压根不需要文法分析），

而是基本构造（条件、过程，等等）对应于寄存器模型的实现。略带讨论了最简单的垃圾回收。

后三章较深，最好略有一点语言、编译和体系结构的基础，或者多些耐心。

***
